
//https_server.c file

#include "https_server.h"
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <unistd.h> 
#include<ctype.h>



void initialize_openssl(){
    // Initialize the OpenSSL library for encryption/decryption algorithms
    SSL_library_init();

    // Load all the necessary error messages for debugging
    SSL_load_error_strings();

    // Load all available cryptographic algorithms (hash, ciphers, etc.)
    OpenSSL_add_all_algorithms();

    // Optionally, seed the PRNG (pseudorandom number generator)
    // This might be handled internally but sometimes needs explicit seeding
    // RAND_load_file("/dev/urandom", 1024); // On UNIX-like systems
}

SSL_CTX* create_ssl_context(const char* cert_file,const char* key_file){
    // Use TLS server method that automatically negotiates highest supported TLS version
    const SSL_METHOD* method = TLS_server_method();
    SSL_CTX* ctx = SSL_CTX_new(method);

   
    if(!ctx){
        fprintf(stderr,"Unable to create SSL context \n");
        ERR_print_errors_fp(stderr);
        return NULL;
    }

    // Set options to improve security (disable SSLv2 and SSLv3)
    SSL_CTX_set_options(ctx,SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);
    
    //Load server certifaction
    if(SSL_CTX_use_certificate_file(ctx,cert_file,SSL_FILETYPE_PEM)<= 0){
        fprintf(stderr, "Error loading certificate from file: %s\n", cert_file);
        ERR_print_errors_fp(stderr);
        SSL_CTX_free(ctx);
        return NULL;
    } 

    //load server private key 
    if(SSL_CTX_use_PrivateKey_file(ctx,key_file,SSL_FILETYPE_PEM)<=0){
        fprintf(stderr, "Error loading private key from file: %s\n", key_file);
        ERR_print_errors_fp(stderr);
        SSL_CTX_free(ctx);
        return NULL;
    }

    if (!SSL_CTX_check_private_key(ctx)) {
        fprintf(stderr, "Private key does not match the certificate public key\n");
        SSL_CTX_free(ctx);
        return NULL;
    }

    return ctx;
}

int create_https_listener(int port){
    int sockfd = socket(AF_INET,SOCK_STREAM,0);
     if (sockfd < 0) {
        perror("Failed to create socket");
        return -1;
    }

    int reuse = 1;
    setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&reuse,sizeof(reuse));

    struct sockaddr_in addr;
    memset(&addr,0,sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);

    if(bind(sockfd, (struct sockaddr*)&addr,sizeof(addr))<0){
        perror("Bind failed");
        close(sockfd);
        return -1;
    }
    
    if(listen(sockfd,10)<0){
     perror("listen failed");
     close(sockfd);
     return -1;
    }
    return sockfd; 
}

/**
 * Accept an SSL/TLS connection:
 *  - Accepts a plain TCP connection from the HTTPS listen socket
 *  - Creates an SSL object using the context
 *  - Associates the socket with the SSL
 *  - Performs SSL handshake
 * 
 * Returns:
 *   On success, returns a pointer to the SSL object (caller must free).
 *   On failure, returns NULL.
 */

SSL* accept_https_connection(SSL_CTX* ctx, int https_listen_sock) {
    struct sockaddr_in client_addr;
    socklen_t addr_len = sizeof(client_addr);

    // Accept a new TCP connection
    int client_sock = accept(https_listen_sock, (struct sockaddr*)&client_addr, &addr_len);
    if (client_sock < 0) {
        perror("Accept failed");
        return NULL;
    }

    // Create a new SSL structure for the connection
    SSL* ssl = SSL_new(ctx);
    if (!ssl) {
        fprintf(stderr, "Unable to create SSL structure\n");
        close(client_sock);
        return NULL;
    }

    // Bind the SSL object with the accepted socket descriptor
    SSL_set_fd(ssl, client_sock);

    // Perform SSL/TLS handshake
    if (SSL_accept(ssl) <= 0) {
        fprintf(stderr, "SSL accept error:\n");
        ERR_print_errors_fp(stderr);
        SSL_free(ssl);
        close(client_sock);
        return NULL;
    }

    // Handshake successful: return SSL pointer to caller
    return ssl;
}

// Wrapper for plain socket recv()
ssize_t recv_wrapper(void* connection, char* buffer, size_t length) {
    int sockfd = *((int*)connection);
    return recv(sockfd, buffer, length, 0);
}

// Wrapper for plain socket send()
ssize_t send_wrapper(void* connection, const char* buffer, size_t length) {
    int sockfd = *((int*)connection);
    return send(sockfd, buffer, length, 0);
}

// Wrapper for SSL_read()
ssize_t ssl_recv_wrapper(void* connection, char* buffer, size_t length) {
    SSL* ssl = (SSL*)connection;
    int ret;
    while (1) {
        ret = SSL_read(ssl, buffer, (int)length);
        if (ret > 0) {
            return ret;
        }
        int err = SSL_get_error(ssl, ret);
        if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE) {
            // Retry on these; could add select/poll here for non-blocking sockets
            continue;
        }
        // Failure or EOF
        return -1;
    }
}

// Wrapper for SSL_write()
ssize_t ssl_send_wrapper(void* connection, const char* buffer, size_t length) {
    SSL* ssl = (SSL*)connection;
    int ret;
    size_t total_sent = 0;
    while (total_sent < length) {
        ret = SSL_write(ssl, buffer + total_sent, (int)(length - total_sent));
        if (ret > 0) {
            total_sent += ret;
        } else {
            int err = SSL_get_error(ssl, ret);
            if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE) {
                // Retry on these; could add select/poll here
                continue;
            }
            // Failure
            return -1;
        }
    }
    return (ssize_t)total_sent;
}

// Reads full HTTP request from SSL socket into a dynamically allocated buffer.
// Parameters:
//   ssl          - pointer to SSL object
//   out_length   - pointer to size_t to store length of returned buffer
// Returns:
//   A malloced pointer with request data (caller must free), or NULL on failure.
// Returns malloc'ed buffer with length stored in out_length (or NULL)
char* read_full_request_ssl(SSL* ssl, size_t* out_length) {
    size_t cap = 8192;
    char* buf = malloc(cap);
    if (!buf) return NULL;
    size_t total = 0;

    // Helper lambda-like function: search for CRLFCRLF in buf[0..total)
    #define FIND_HDR_END(buf, total) \
        ({ size_t _i = 0; ssize_t _pos = -1; \
           for (_i = 0; _i + 3 < (total); ++_i) { \
               if (buf[_i] == '\r' && buf[_i+1] == '\n' && buf[_i+2] == '\r' && buf[_i+3] == '\n') { _pos = (ssize_t)_i; break; } } _pos; })

    ssize_t hdr_end_pos = -1;

    // Read until we find header end
    while (1) {
        if (total + 4096 > cap) {
            size_t newcap = cap * 2;
            char* n = realloc(buf, newcap);
            if (!n) { free(buf); return NULL; }
            buf = n; cap = newcap;
        }

        int bytes = SSL_read(ssl, buf + total, (int)(cap - total));
        if (bytes <= 0) {
            int err = SSL_get_error(ssl, bytes);
            // treat WANT_READ/WANT_WRITE as retry; otherwise error
            if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE) {
                // short sleep to avoid busy loop
                usleep(1000);
                continue;
            }
            free(buf);
            return NULL;
        }
        total += bytes;

        hdr_end_pos = FIND_HDR_END(buf, total);
        if (hdr_end_pos >= 0) break;
        // safety: limit header size to say 64KB
        if (total > 64 * 1024) { free(buf); return NULL; }
    }

    size_t header_len = (size_t)hdr_end_pos + 4;
    // find Content-Length header in a case-insensitive way (simple approach)
    size_t content_length = 0;
    for (size_t i = 0; i + 15 < header_len; ++i) {
        // compare case-insensitive for "content-length:"
        if ((buf[i] == 'C' || buf[i] == 'c') &&
            (buf[i+1] == 'o' || buf[i+1] == 'O')) {
            // naive check - better to parse headers properly afterwards
            if (strncasecmp(buf + i, "Content-Length:", 15) == 0) {
                // parse digits after the colon
                char tmp[32] = {0};
                size_t j = i + 15;
                while (j < header_len && (buf[j] == ' ' || buf[j] == '\t')) ++j;
                size_t k = 0;
                while (j < header_len && k + 1 < sizeof(tmp) && isdigit((unsigned char)buf[j])) {
                    tmp[k++] = buf[j++];
                }
                tmp[k] = '\0';
                content_length = (size_t)atoi(tmp);
                break;
            }
        }
    }

    // Read remaining body bytes if any
    size_t body_already = total - header_len;
    size_t body_needed = (content_length > body_already) ? (content_length - body_already) : 0;
    while (body_needed > 0) {
        if (total + 4096 > cap) {
            size_t newcap = cap * 2;
            char* n = realloc(buf, newcap);
            if (!n) { free(buf); return NULL; }
            buf = n; cap = newcap;
        }
        int bytes = SSL_read(ssl, buf + total, (int)(cap - total));
        if (bytes <= 0) {
            int err = SSL_get_error(ssl, bytes);
            if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE) {
                usleep(1000);
                continue;
            }
            free(buf);
            return NULL;
        }
        total += bytes;
        if (bytes <= (int)body_needed) body_needed -= bytes;
        else body_needed = 0;
    }

    // Null terminate for convenience (buf[total] reserved)
    char* n = realloc(buf, total + 1);
    if (n) { buf = n; }
    buf[total] = '\0';
    if (out_length) *out_length = total;
    return buf;
    #undef FIND_HDR_END
}




// main.c
//command to run program
//gcc main.c http_handler.c https_server.c session.c auth.c php_handler.c thread_safe.c -lssl -lcrypto -lpthread -luuid  -o server


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <unistd.h>
#include <libgen.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

#include "http_handler.h"
#include "https_server.h"
#include "thread_safe.h"
#include "php_handler.h"
#include "session.h"
#include "auth.h"

#define HTTP_PORT 8080
#define HTTPS_PORT 8443  // Use 443 for standard HTTPS if permitted
#define BUFFER_SIZE 8192

// Forward declarations for thread handler functions
void* handle_http_client(void* arg);
void* handle_https_client(void* arg);


/**
 * @brief Thread function to handle a single client connection.
 * @param arg The client socket file descriptor.
 * @return NULL.
 */
void handle_client(int c) {
    // Read the full HTTP request from the client socket.
    // int c = *((int*)arg);
    // free(arg); // Free the memory allocated in the main thread

    // Check for a valid socket before proceeding
    if (c < 0) {
        printf("Invalid client socket.\n");
        return;
    } 
   size_t request_length = 0;
    // char *request = read_full_request(c,&request_length);
    char *request = read_full_request(c,&request_length);
    if (!request) {
        printf("Failed to read request.\n");
        close(c);
        return;
    }

    // Parse the raw request string into a structured httpreq object.
    httpreq *req = parse_http(request);
    if (!req) {
        printf("Failed to parse request.\n");
        free(request);
        return ;
    }

    // Extract the session ID from the request headers to authenticate the user.
    const char *session_id = get_session_id_from_request(request);
    Session *session = NULL;
    if (session_id) {
         session = get_session_ts(session_id);
        //session = get_session(session_id);
    }
    
    // Log the received request for debugging purposes.
    printf("Received request: Method=%s, URL=%s\n", req->method, req->url);

  


    // Route a POST request to create a new folder.
    if (strcmp(req->url, "/create_folder") == 0 && strcmp(req->method, "POST") == 0) {
        if (!session) {
            http_send_redirect(c, "/login");
        } else {
            // Call the handler to create the folder based on the POST data.
            char path[256] = "/";
            char foldername[256];
            const char *body = strstr(request, "\r\n\r\n") + 4;
          //if(  get_post_param(body, "path", path, sizeof(path)) &&
          //  get_post_param(body, "foldername", foldername, sizeof(foldername))){
            if (handle_create_folder(request, session->username)) {
                // On success, redirect the user back to the current directory.
               
                char redirect_url[640];
                 // normalize_path(redirect_url, path, foldername); // Use your new function
                 //http_send_redirect(c, redirect_url);
                 snprintf(redirect_url, sizeof(redirect_url), "/dashboard?path=%s", path);
                 http_send_redirect(c, redirect_url);
            } else {
                // Failure: Redirect back to the original path
        // char redirect_url[640];
        // snprintf(redirect_url, sizeof(redirect_url), "/dashboard?path=%s", path);
        // http_send_redirect(c, redirect_url);
                // char redirect_url[300];
                http_send_response(c, 500, "text/plain", "Failed to create folder", 24);
            }
       // }else{
          //  printf("handle_client():failed to find %s or %s :Cre_fol \n",path,foldername);
          //  fflush(stdout);
       // }
        }
    }
    // Route a POST request to delete a folder.
    else if (strcmp(req->url, "/delete_folder") == 0 && strcmp(req->method, "POST") == 0) {
        if (!session) {
            http_send_redirect(c, "/login");
        } else {
            // Call the handler to delete the folder based on the POST data.
            if (http_handle_delete_folder(request, session->username)) {
                // On success, redirect the user back to the parent directory.
                char path[256] = "/";
                // char *foldername;
                const char *body = strstr(request, "\r\n\r\n") + 4;
                get_post_param(body, "path", path, sizeof(path));
                //get_post_param(body, "foldername", foldername, sizeof(foldername));
                
                  // Check if the current path is the root directory
    //           if (strcmp(path, "/") == 0) {
    //            snprintf(redirect_url, sizeof(redirect_url), "/dashboard?path=%s%s", path, foldername);
    //           } else {
    //     // Concatenate with a forward slash for nested folders
    //           snprintf(redirect_url, sizeof(redirect_url), "/dashboard?path=%s/%s", path, foldername);
    // }
                char redirect_url[300];
                snprintf(redirect_url, sizeof(redirect_url), "/dashboard?path=%s", path);
                http_send_redirect(c, redirect_url);
            } else {
                http_send_response(c, 500, "text/plain", "Failed to delete folder", 24);
            }
        }
    }
    // Route requests to the dashboard page. This includes the base URL and URLs with a path parameter.
    else if (strstr(req->url, "/dashboard") == req->url) {
        if (!session) {
            http_send_redirect(c, "/login");
        } else {
            // Extract the 'path' parameter from the URL query string.
            char path[256] = "/";
            const char *path_param = strstr(req->url, "path=");
            if (path_param) {
                // Decode the URL-encoded path before using it.
                urldecode(path, path_param + strlen("path="));
            }
            // Pass the parsed path to the dashboard handler.
            http_send_dashboard(c, session->username, path);
        }
    }

    // --- EXISTING ROUTING LOGIC ---

    // Route a GET request for the root page.
    else if (strcmp(req->url, "/") == 0 && strcmp(req->method, "GET") == 0) {
        if (session) {
            http_send_redirect(c, "/dashboard?path=/");
        } else {
            http_send_welcome_page(c);
        }
    } 
    // Route a GET request for the login page.
    else if (strcmp(req->url, "/login") == 0 && strcmp(req->method, "GET") == 0) {
        http_send_login_page(c);
    } 
    // Route a POST request for login authentication.
    else if (strcmp(req->url, "/login") == 0 && strcmp(req->method, "POST") == 0) {
        char username[MAX_USERNAME_LENGTH + 1], password[256];
        const char *body = strstr(request, "\r\n\r\n") + 4;
        if (get_post_param(body, "username", username, sizeof(username)) &&
            get_post_param(body, "password", password, sizeof(password))) {
            if (authenticate_user(username, password)) {
                Session *new_session = create_session_ts(username);
                http_send_redirect_with_cookie(c, "/dashboard?path=/", new_session->session_id);
            } else {
                http_send_response(c, 401, "text/html", "<h1>Unauthorized</h1><p>Incorrect username or password.</p>", 60);
            }
        } else {
            http_send_response(c, 400, "text/plain", "Bad Request", 11);
        }
    }
    // Route a GET request for the registration page.
    else if (strcmp(req->url, "/register") == 0 && strcmp(req->method, "GET") == 0) {
        http_send_register_page(c);
    }
    // Route a POST request for user registration.
    else if (strcmp(req->url, "/register") == 0 && strcmp(req->method, "POST") == 0) {
        char username[MAX_USERNAME_LENGTH + 1], password[256];
        const char *body = strstr(request, "\r\n\r\n") + 4;
        if (get_post_param(body, "username", username, sizeof(username)) &&
            get_post_param(body, "password", password, sizeof(password))) {
            if (register_user(username, password)) {
                http_send_redirect(c, "/login");
            } else {
                http_send_response(c, 500, "text/html", "<h1>Error</h1><p>Failed to register user.</p>", 47);
            }
        } else {
            http_send_response(c, 400, "text/plain", "Bad Request", 11);
        }
    }
    // Route a POST request for file upload.
   // In handle_client function, replace the upload handling:
else if (strcmp(req->url, "/upload") == 0 && strcmp(req->method, "POST") == 0) {
    if (!session) {
        http_send_redirect(c, "/login");
    } else {
        const char *content_length_str = find_header(request, "Content-Length:");
        int content_length = content_length_str ? atoi(content_length_str) : 0;
        
        printf("Processing file upload, content length: %d\n", content_length);
        
        // Get the actual request length
        size_t request_len = strlen(request); // This will be updated in read_full_request
        
        // For all file types, use the same upload handler
        if (http_handle_upload(c, request, session->username, content_length)) {
            // Extract path for redirect
            char path[256] = "/";
            const char *body = strstr(request, "\r\n\r\n");
            if (body) {
                body += 4;
                get_post_param(body, "path", path, sizeof(path));
            }
            
            char redirect_url[300];
            snprintf(redirect_url, sizeof(redirect_url), "/dashboard?path=%s", path);
            http_send_redirect(c, redirect_url);
        } else {
            http_send_response(c, 500, "text/plain", "Upload failed", 13);
        }
    }
}

    // Route a POST request for file deletion.
    else if (strcmp(req->url, "/delete_file") == 0 && strcmp(req->method, "POST") == 0) {
        if (!session) {
            http_send_redirect(c, "/login");
        } else {
            if (http_handle_delete_file(request, session->username)) {
                char path[256] = "/";
                const char *body = strstr(request, "\r\n\r\n") + 4;
                get_post_param(body, "path", path, sizeof(path));
                char redirect_url[300];
                snprintf(redirect_url, sizeof(redirect_url), "/dashboard?path=%s", path);
                http_send_redirect(c, redirect_url);
            } else {
                http_send_response(c, 500, "text/plain", "Failed to delete file", 22);
            }
        }
    }
    // Route a POST request for logout.
    else if (strcmp(req->url, "/logout") == 0 && strcmp(req->method, "POST") == 0) {
        if (session) {
            delete_session_ts(session->session_id);
        }
        http_send_redirect(c, "/");
    }
     //Get request to handel get for php file
    // else if(has_file_extension(req->url,".php")){
    //  if(!session){
    //  http_send_redirect(c, "/login"); 
    //  }else{
    //     http_handle_php(c,req,request,session->username);
    //  }
    // }
    else if (strstr(req->url, "/user_files/") == req->url) {
    // If the URL is a request to a user's file, handle it here.
    if (!session) {
        http_send_redirect(c, "/login");
    } else {
        if (has_file_extension(req->url, ".php")) {
            // It's a PHP script, run the PHP handler
            http_handle_php(c, req, request, session->username);
        } else {
            // It's a static file, run the static file handler
            http_handle_view_file(c, req->url, session->username);
        }
    }
}
    // Route a GET request to view a file.
    else if (strstr(req->url, "/view_file") == req->url && strcmp(req->method, "GET") == 0) {
        if (!session) {
            http_send_redirect(c, "/login");
        } else {
            if(has_file_extension(req->url,".php")){
               http_handle_php(c,req,request,session->username);
            }else{
                http_handle_view_file(c, req->url, session->username);
            }
                 
            
        }
    }
    // Route a GET request to download a file.
    else if (strstr(req->url, "/download_file") == req->url && strcmp(req->method, "GET") == 0) {
        if (!session) {
            http_send_redirect(c, "/login");
        } else {
            http_send_file_for_download(c, req->url, session->username);
        }
    }
   
    // Handle all other unrecognized requests with a 404 Not Found response.
    else {
        http_send_response(c, 404, "text/plain", "Not Found", 9);
    }
    
    // Clean up allocated memory.
    free(req->method);
    free(req->url);
    free(req->protocol);
    free(req);
    free(request);
    close(c);
}

/**
 * @brief Checks if a request URL matches a specific path.
 * @param request_url The URL from the request.
 * @param path The path to check against.
 * @return true if the URL matches the path exactly, false otherwise.
 */
bool url_matches(const char *request_url, const char *path) {
    size_t path_len = strlen(path);
    return (strncmp(request_url, path, path_len) == 0 &&
           (request_url[path_len] == '\0' || request_url[path_len] == '?'));
}

int main() {
    int http_sock, https_sock;
    struct sockaddr_in server_addr;
    
    // Initialize OpenSSL
    initialize_openssl();
    
    // Create SSL context
    SSL_CTX* ssl_ctx = create_ssl_context("cert.pem", "key.pem");
    if (!ssl_ctx) {
        fprintf(stderr, "Failed to create SSL context\n");
        return EXIT_FAILURE;
    }
    
    // Create HTTP socket
    http_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (http_sock < 0) {
        perror("HTTP socket creation failed");
        SSL_CTX_free(ssl_ctx);
        return EXIT_FAILURE;
    }
    
    int reuse = 1;
    setsockopt(http_sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
    
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(HTTP_PORT);
    
    if (bind(http_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("HTTP bind failed");
        SSL_CTX_free(ssl_ctx);
        close(http_sock);
        return EXIT_FAILURE;
    }
    
    if (listen(http_sock, 5) < 0) {
        perror("HTTP listen failed");
        SSL_CTX_free(ssl_ctx);
        close(http_sock);
        return EXIT_FAILURE;
    }
    
    // Create HTTPS listening socket using helper function
    https_sock = create_https_listener(HTTPS_PORT);
    if (https_sock < 0) {
        fprintf(stderr, "Failed to create HTTPS listener socket\n");
        SSL_CTX_free(ssl_ctx);
        close(http_sock);
        return EXIT_FAILURE;
    }

    printf("Server listening on HTTP port %d and HTTPS port %d\n", HTTP_PORT, HTTPS_PORT);
    fflush(stdout);
    
    fd_set readfds;
    int max_fd = (http_sock > https_sock) ? http_sock : https_sock;
    
    while (1) {
        FD_ZERO(&readfds);
        FD_SET(http_sock, &readfds);
        FD_SET(https_sock, &readfds);
        
        int activity = select(max_fd + 1, &readfds, NULL, NULL, NULL);
        if (activity < 0) {
            perror("select error");
            continue;
        }
        
        // Handle HTTP connection
        if (FD_ISSET(http_sock, &readfds)) {
            int* client_sock = malloc(sizeof(int));
            if (!client_sock) {
                perror("Failed to allocate memory for HTTP client socket");
                continue;
            }
            *client_sock = accept(http_sock, NULL, NULL);
            if (*client_sock < 0) {
                perror("HTTP accept failed");
                free(client_sock);
                continue;
            }
            pthread_t tid;
            pthread_create(&tid, NULL, handle_http_client, client_sock);
            pthread_detach(tid);
        }
        
        // Handle HTTPS connection
        if (FD_ISSET(https_sock, &readfds)) {
            SSL* ssl_client = accept_https_connection(ssl_ctx, https_sock);
            if (!ssl_client) {
                fprintf(stderr, "SSL accept failed for HTTPS client\n");
                continue;
            }
            pthread_t tid;
            pthread_create(&tid, NULL, handle_https_client, ssl_client);
            pthread_detach(tid);
        }
    }
    
    close(http_sock);
    close(https_sock);
    SSL_CTX_free(ssl_ctx);
    return EXIT_SUCCESS;
}

// Thread function for handling HTTP connections (existing code)
void* handle_http_client(void* arg) {
    int client_sock = *((int*)arg);
    free(arg);
    handle_client(client_sock);  // Reuse existing handle_client with socket
    return NULL;
}

// Thread function for handling HTTPS connections
void* handle_https_client(void* arg) {
    SSL* ssl = (SSL*)arg;

    size_t request_length = 0;
    char* request = read_full_request_ssl(ssl, &request_length);
    if (!request) {
        SSL_shutdown(ssl);
        int sockfd = SSL_get_fd(ssl);
        SSL_free(ssl);
        close(sockfd);
        return NULL;
    }

    httpreq* req = parse_http(request);
    if (!req) {
        free(request);
        SSL_shutdown(ssl);
        int sockfd = SSL_get_fd(ssl);
        SSL_free(ssl);
        close(sockfd);
        return NULL;
    }

    // For demonstration, simple GET "/" handling
    if (strcmp(req->url, "/") == 0 && strcmp(req->method, "GET") == 0) {
        const char* response_body = "<html><body><h1>Welcome to the HTTPS server!</h1></body></html>";
        char header[512];
        snprintf(header, sizeof(header),
                 "HTTP/1.1 200 OK\r\n"
                 "Content-Type: text/html\r\n"
                 "Content-Length: %zu\r\n"
                 "Connection: close\r\n"
                 "\r\n",
                 strlen(response_body));

        // Send headers
        ssl_send_wrapper(ssl, header, strlen(header));
        // Send body
        ssl_send_wrapper(ssl, response_body, strlen(response_body));
    } else {
        // Handle other routes or send 404
        const char* response_body = "Not Found";
        char header[512];
        snprintf(header, sizeof(header),
                 "HTTP/1.1 404 Not Found\r\n"
                 "Content-Type: text/plain\r\n"
                 "Content-Length: %zu\r\n"
                 "Connection: close\r\n"
                 "\r\n",
                 strlen(response_body));

        ssl_send_wrapper(ssl, header, strlen(header));
        ssl_send_wrapper(ssl, response_body, strlen(response_body));
    }

    free(req->method);
    free(req->url);
    free(req->protocol);
    free(req);

    free(request);

    SSL_shutdown(ssl);
    int sockfd = SSL_get_fd(ssl);
    SSL_free(ssl);
    close(sockfd);
    return NULL;
}

